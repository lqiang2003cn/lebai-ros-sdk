@staticmethod
    def convertCloudFromRosToOpen3d(ros_cloud):

        parray = ros_numpy.point_cloud2.pointcloud2_to_array(ros_cloud)

        # mask = np.load('masks.npy')[0].reshape(-1)

        # Get cloud data from ros_cloud
        field_names = [field.name for field in ros_cloud.fields]
        cloud_data = list(pc2.read_points(ros_cloud, skip_nans=True, field_names=field_names))

        # Check empty
        # open3d_cloud = open3d.PointCloud()
        if len(cloud_data) == 0:
            print("Converting an empty cloud")
            return None

        rgb = None

        # Set open3d_cloud
        if "rgb" in field_names:
            IDX_RGB_IN_FIELD = 3  # x, y, z, rgb

            # Get xyz
            xyz = [Point32(x, y, z) for x, y, z, rgb in cloud_data]  # (why cannot put this line below rgb?)

            # Get rgb
            # Check whether int or float
            if type(cloud_data[0][IDX_RGB_IN_FIELD]) == float:  # if float (from pcl::toROSMsg)
                rgb = [convert_rgbFloat_to_tuple(rgb) for x, y, z, rgb in cloud_data]
            else:
                rgb = [convert_rgbUint32_to_tuple(rgb) for x, y, z, rgb in cloud_data]

            # combine
            # open3d_cloud.points = open3d.Vector3dVector(np.array(xyz))
            # open3d_cloud.colors = open3d.Vector3dVector(np.array(rgb) / 255.0)
        else:
            xyz = [(x, y, z) for x, y, z in cloud_data]  # get xyz
            # open3d_cloud.points = open3d.Vector3dVector(np.array(xyz))

        # return
        return rgb, xyz

